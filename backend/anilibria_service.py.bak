import aiohttp
import logging
import os
from pathlib import Path
from typing import Optional, List, Dict, Any
from fastapi import HTTPException
from genre_mapping import get_genre_image_filename

logger = logging.getLogger(__name__)

ANILIBRIA_API_BASE = "https://api.anilibria.app/api/v1"
ANILIBRIA_CDN_BASE = "https://anilibria.tv"

# Path to custom genre images
GENRE_IMAGES_DIR = Path(__file__).parent.parent / "public" / "genre-images"


class AniLibriaService:
    """Service for interacting with AniLibria API"""
    
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session"""
        if self.session is None or self.session.closed:
            self.session = aiohttp.ClientSession()
        return self.session
    
    async def close(self):
        """Close aiohttp session"""
        if self.session and not self.session.closed:
            await self.session.close()
    
    async def _make_request(self, endpoint: str, params: Optional[Dict] = None) -> Any:
        """Make request to AniLibria API"""
        url = f"{ANILIBRIA_API_BASE}{endpoint}"
        session = await self.get_session()
        
        logger.info(f"ðŸ”„ Making request to AniLibria: {url} with params: {params}")
        
        try:
            async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=30)) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(f"âœ… AniLibria API success: {len(data) if isinstance(data, list) else 'single'} item(s)")
                    return data
                else:
                    logger.error(f"âŒ AniLibria API error: {response.status} for {url}")
                    raise HTTPException(status_code=response.status, detail=f"AniLibria API error: {response.status}")
        except aiohttp.ClientError as e:
            logger.error(f"âŒ Request error to AniLibria API: {str(e)}")
            raise HTTPException(status_code=500, detail=f"Failed to connect to AniLibria API: {str(e)}")
    
    def _process_poster_url(self, poster: Optional[Dict]) -> Optional[str]:
        """Process poster URL to add CDN base"""
        if not poster:
            return None
        
        # Prefer optimized webp version
        if poster.get("optimized") and poster["optimized"].get("src"):
            return f"{ANILIBRIA_CDN_BASE}{poster['optimized']['src']}"
        elif poster.get("src"):
            return f"{ANILIBRIA_CDN_BASE}{poster['src']}"
        
        return None
    
    def _process_release(self, release: Dict) -> Dict:
        """Process release data to add full URLs"""
        if "poster" in release:
            release["poster_url"] = self._process_poster_url(release["poster"])
        
        if "latest_episode" in release and release["latest_episode"]:
            episode = release["latest_episode"]
            if "preview" in episode:
                preview = episode["preview"]
                if preview.get("optimized") and preview["optimized"].get("preview"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['optimized']['preview']}"
                elif preview.get("preview"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['preview']}"
                elif preview.get("src"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['src']}"
        
        return release
    
    async def get_latest_releases(self, limit: int = 12, offset: int = 0) -> List[Dict]:
        """Get latest releases"""
        params = {"limit": limit, "offset": offset}
        data = await self._make_request("/anime/releases/latest", params)
        return [self._process_release(release) for release in data]
    
    async def get_release_by_id(self, release_id: int) -> Dict:
        """Get release by ID"""
        data = await self._make_request(f"/anime/releases/{release_id}")
        return self._process_release(data)
    
    async def get_release_by_alias(self, alias: str) -> Dict:
        """Get release by alias"""
        data = await self._make_request(f"/anime/releases/alias/{alias}")
        return self._process_release(data)
    
    async def get_episodes(self, release_id: int) -> List[Dict]:
        """Get episodes for a release"""
        data = await self._make_request(f"/anime/releases/{release_id}")
        episodes = data.get("episodes", []) if isinstance(data, dict) else []

        # Process episode previews
        for episode in episodes:
            if "preview" in episode:
                preview = episode["preview"]
                if preview.get("optimized") and preview["optimized"].get("preview"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['optimized']['preview']}"
                elif preview.get("preview"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['preview']}"
                elif preview.get("src"):
                    episode["preview_url"] = f"{ANILIBRIA_CDN_BASE}{preview['src']}"

        return episodes
    
    async def search_releases(
        self, 
        query: Optional[str] = None,
        genres: Optional[List[int]] = None,
        year: Optional[int] = None,
        season: Optional[str] = None,
        limit: int = 12,
        offset: int = 0
    ) -> List[Dict]:
        """Search releases with filters"""
        fetch_limit = max(min(limit + offset, 50), 20)
        params = {"limit": fetch_limit, "offset": 0}
        data = await self._make_request("/anime/releases/latest", params)

        filtered: List[Dict] = []
        for release in data:
            if query:
                name = release.get("name", {}) or {}
                haystack = " ".join(
                    str(value).lower()
                    for value in [
                        name.get("main"),
                        name.get("english"),
                        name.get("alternative"),
                        release.get("alias"),
                    ]
                    if value
                )
                if query.lower() not in haystack:
                    continue

            if year and release.get("year") != year:
                continue

            if season:
                season_value = release.get("season", {}) or {}
                season_raw = season_value.get("value") or season_value.get("description")
                if not season_raw or str(season_raw).lower() != str(season).lower():
                    continue

            if genres:
                release_genres = release.get("genres", [])
                genre_ids = [g.get("id") for g in release_genres if isinstance(g, dict)]
                if not any(gid in genre_ids for gid in genres):
                    continue

            filtered.append(self._process_release(release))

        sliced = filtered[offset:offset + limit]
        return sliced
    
    async def get_schedule(self) -> Dict:
        """Get release schedule"""
        data = await self._make_request("/anime/releases/latest", {"limit": 50, "offset": 0})

        from datetime import datetime

        today = datetime.utcnow().isoweekday()
        yesterday = 7 if today == 1 else today - 1
        tomorrow = 1 if today == 7 else today + 1

        schedule = {
            "yesterday": [],
            "today": [],
            "tomorrow": [],
        }

        for release in data:
            publish_day = release.get("publish_day", {}) or {}
            day_value = publish_day.get("value")
            if day_value == yesterday:
                schedule["yesterday"].append(self._process_release(release))
            elif day_value == today:
                schedule["today"].append(self._process_release(release))
            elif day_value == tomorrow:
                schedule["tomorrow"].append(self._process_release(release))

        return schedule
    
    async def get_genres(self) -> List[Dict]:
        """Get all genres with custom images"""
        data = await self._make_request("/anime/catalog/references/genres")
        
        # Process genre images - prefer custom local images over CDN
        for genre in data:
            genre_name = genre.get("name", "")
            custom_image_used = False
            
            if genre_name:
                # Try to find custom genre image
                image_filename = get_genre_image_filename(genre_name)
                
                # Check for WebP, JPG, or PNG in that order
                for ext in ['.webp', '.jpg', '.jpeg', '.png']:
                    image_path = GENRE_IMAGES_DIR / f"{image_filename}{ext}"
                    if image_path.exists():
                        # Use relative URL that frontend can access
                        genre["image_url"] = f"/genre-images/{image_filename}{ext}"
                        genre["custom_image"] = True
                        custom_image_used = True
                        logger.info(f"âœ… Using custom image for genre '{genre_name}': {image_filename}{ext}")
                        break
            
            # Fallback to AniLibria CDN if no custom image found
            if not custom_image_used and "image" in genre:
                image = genre["image"]
                if image.get("optimized") and image["optimized"].get("preview"):
                    genre["image_url"] = f"{ANILIBRIA_CDN_BASE}{image['optimized']['preview']}"
                elif image.get("preview"):
                    genre["image_url"] = f"{ANILIBRIA_CDN_BASE}{image['preview']}"
                genre["custom_image"] = False
        
        return data
    
    async def get_franchises(self, limit: int = 12, offset: int = 0) -> List[Dict]:
        """Get franchises"""
        params = {"limit": limit, "offset": offset}
        data = await self._make_request("/anime/franchises", params)
        
        # Process franchise images
        for franchise in data:
            if "image" in franchise:
                image = franchise["image"]
                if image.get("optimized") and image["optimized"].get("preview"):
                    franchise["image_url"] = f"{ANILIBRIA_CDN_BASE}{image['optimized']['preview']}"
                elif image.get("preview"):
                    franchise["image_url"] = f"{ANILIBRIA_CDN_BASE}{image['preview']}"
                elif image.get("src"):
                    franchise["image_url"] = f"{ANILIBRIA_CDN_BASE}{image['src']}"
        
        return data
    
    async def get_torrents(self, limit: int = 20, offset: int = 0) -> List[Dict]:
        """Get latest torrents"""
        params = {"limit": limit, "offset": offset}
        data = await self._make_request("/anime/torrents", params)
        torrents = data.get("data", data) if isinstance(data, dict) else data

        for torrent in torrents:
            release = torrent.get("release")
            if isinstance(release, dict):
                torrent["release"] = self._process_release(release)

        return torrents
    
    async def get_videos(self, limit: int = 12, offset: int = 0) -> List[Dict]:
        """Get latest videos"""
        params = {"limit": limit, "offset": offset}
        data = await self._make_request("/media/videos", params)
        
        # Process video previews
        for video in data:
            if "image" in video:
                image = video["image"]
                if image.get("optimized") and image["optimized"].get("preview"):
                    video["preview_url"] = f"{ANILIBRIA_CDN_BASE}{image['optimized']['preview']}"
                elif image.get("preview"):
                    video["preview_url"] = f"{ANILIBRIA_CDN_BASE}{image['preview']}"
        
        return data


# Global service instance
anilibria_service = AniLibriaService()
